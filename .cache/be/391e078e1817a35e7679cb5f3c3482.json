{"id":"zRZ1","dependencies":[{"name":"C:\\Projetos\\adekz\\corporatefront_widget\\package.json","includedInParent":true,"mtime":1688673350195},{"name":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\package.json","includedInParent":true,"mtime":1688672641386},{"name":"../../utils/mix.mjs","loc":{"line":1,"column":20,"index":20},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\projection\\styles\\scale-box-shadow.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\utils\\mix.mjs"},{"name":"../../value/types/complex/index.mjs","loc":{"line":2,"column":24,"index":67},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\projection\\styles\\scale-box-shadow.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\value\\types\\complex\\index.mjs"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.correctBoxShadow = void 0;\nvar _mix = require(\"../../utils/mix.mjs\");\nvar _index = require(\"../../value/types/complex/index.mjs\");\nconst correctBoxShadow = {\n  correct: (latest, {\n    treeScale,\n    projectionDelta\n  }) => {\n    const original = latest;\n    const shadow = _index.complex.parse(latest);\n    // TODO: Doesn't support multiple shadows\n    if (shadow.length > 5) return original;\n    const template = _index.complex.createTransformer(latest);\n    const offset = typeof shadow[0] !== \"number\" ? 1 : 0;\n    // Calculate the overall context scale\n    const xScale = projectionDelta.x.scale * treeScale.x;\n    const yScale = projectionDelta.y.scale * treeScale.y;\n    shadow[0 + offset] /= xScale;\n    shadow[1 + offset] /= yScale;\n    /**\n     * Ideally we'd correct x and y scales individually, but because blur and\n     * spread apply to both we have to take a scale average and apply that instead.\n     * We could potentially improve the outcome of this by incorporating the ratio between\n     * the two scales.\n     */\n    const averageScale = (0, _mix.mix)(xScale, yScale, 0.5);\n    // Blur\n    if (typeof shadow[2 + offset] === \"number\") shadow[2 + offset] /= averageScale;\n    // Spread\n    if (typeof shadow[3 + offset] === \"number\") shadow[3 + offset] /= averageScale;\n    return template(shadow);\n  }\n};\nexports.correctBoxShadow = correctBoxShadow;"},"sourceMaps":null,"error":null,"hash":"0cf96906853bfadaf195569736867970","cacheData":{"env":{}}}