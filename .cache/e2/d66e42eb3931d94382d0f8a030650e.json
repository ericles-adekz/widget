{"id":"fIyW","dependencies":[{"name":"C:\\Projetos\\adekz\\corporatefront_widget\\package.json","includedInParent":true,"mtime":1688673350195},{"name":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\package.json","includedInParent":true,"mtime":1688672641386},{"name":"../../../utils/errors.mjs","loc":{"line":1,"column":26,"index":26},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\dom\\utils\\css-variables-conversion.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\utils\\errors.mjs"},{"name":"./is-css-variable.mjs","loc":{"line":2,"column":35,"index":90},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\dom\\utils\\css-variables-conversion.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\dom\\utils\\is-css-variable.mjs"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseCSSVariable = parseCSSVariable;\nexports.resolveCSSVariables = resolveCSSVariables;\nvar _errors = require(\"../../../utils/errors.mjs\");\nvar _isCssVariable = require(\"./is-css-variable.mjs\");\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\nconst splitCSSVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction parseCSSVariable(current) {\n  const match = splitCSSVariableRegex.exec(current);\n  if (!match) return [,];\n  const [, token, fallback] = match;\n  return [token, fallback];\n}\nconst maxDepth = 4;\nfunction getVariableValue(current, element, depth = 1) {\n  (0, _errors.invariant)(depth <= maxDepth, `Max CSS variable fallback depth detected in property \"${current}\". This may indicate a circular fallback dependency.`);\n  const [token, fallback] = parseCSSVariable(current);\n  // No CSS variable detected\n  if (!token) return;\n  // Attempt to read this CSS variable off the element\n  const resolved = window.getComputedStyle(element).getPropertyValue(token);\n  if (resolved) {\n    return resolved.trim();\n  } else if ((0, _isCssVariable.isCSSVariableToken)(fallback)) {\n    // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n    return getVariableValue(fallback, element, depth + 1);\n  } else {\n    return fallback;\n  }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\nfunction resolveCSSVariables(visualElement, {\n  ...target\n}, transitionEnd) {\n  const element = visualElement.current;\n  if (!(element instanceof Element)) return {\n    target,\n    transitionEnd\n  };\n  // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n  // only if they change but I think this reads clearer and this isn't a performance-critical path.\n  if (transitionEnd) {\n    transitionEnd = {\n      ...transitionEnd\n    };\n  }\n  // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n  visualElement.values.forEach(value => {\n    const current = value.get();\n    if (!(0, _isCssVariable.isCSSVariableToken)(current)) return;\n    const resolved = getVariableValue(current, element);\n    if (resolved) value.set(resolved);\n  });\n  // Cycle through every target property and resolve CSS variables. Currently\n  // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n  for (const key in target) {\n    const current = target[key];\n    if (!(0, _isCssVariable.isCSSVariableToken)(current)) continue;\n    const resolved = getVariableValue(current, element);\n    if (!resolved) continue;\n    // Clone target if it hasn't already been\n    target[key] = resolved;\n    if (!transitionEnd) transitionEnd = {};\n    // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n    // CSS variable. This will ensure that after the animation the component will reflect\n    // changes in the value of the CSS variable.\n    if (transitionEnd[key] === undefined) {\n      transitionEnd[key] = current;\n    }\n  }\n  return {\n    target,\n    transitionEnd\n  };\n}"},"sourceMaps":null,"error":null,"hash":"65aeefaf24d8d20d3e3f35a5f14b8456","cacheData":{"env":{}}}