{"id":"EBjz","dependencies":[{"name":"C:\\Projetos\\adekz\\corporatefront_widget\\package.json","includedInParent":true,"mtime":1688673350195},{"name":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\package.json","includedInParent":true,"mtime":1688672641386},{"name":"./inset.mjs","loc":{"line":1,"column":26,"index":26},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\dom\\scroll\\offsets\\index.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\dom\\scroll\\offsets\\inset.mjs"},{"name":"./presets.mjs","loc":{"line":2,"column":29,"index":70},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\dom\\scroll\\offsets\\index.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\dom\\scroll\\offsets\\presets.mjs"},{"name":"./offset.mjs","loc":{"line":3,"column":30,"index":117},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\dom\\scroll\\offsets\\index.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\dom\\scroll\\offsets\\offset.mjs"},{"name":"../../../../utils/interpolate.mjs","loc":{"line":4,"column":28,"index":161},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\dom\\scroll\\offsets\\index.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\utils\\interpolate.mjs"},{"name":"../../../../utils/offsets/default.mjs","loc":{"line":5,"column":30,"index":228},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\dom\\scroll\\offsets\\index.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\utils\\offsets\\default.mjs"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveOffsets = resolveOffsets;\nvar _inset = require(\"./inset.mjs\");\nvar _presets = require(\"./presets.mjs\");\nvar _offset = require(\"./offset.mjs\");\nvar _interpolate = require(\"../../../../utils/interpolate.mjs\");\nvar _default = require(\"../../../../utils/offsets/default.mjs\");\nconst point = {\n  x: 0,\n  y: 0\n};\nfunction resolveOffsets(container, info, options) {\n  let {\n    offset: offsetDefinition = _presets.ScrollOffset.All\n  } = options;\n  const {\n    target = container,\n    axis = \"y\"\n  } = options;\n  const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n  const inset = target !== container ? (0, _inset.calcInset)(target, container) : point;\n  /**\n   * Measure the target and container. If they're the same thing then we\n   * use the container's scrollWidth/Height as the target, from there\n   * all other calculations can remain the same.\n   */\n  const targetSize = target === container ? {\n    width: container.scrollWidth,\n    height: container.scrollHeight\n  } : {\n    width: target.clientWidth,\n    height: target.clientHeight\n  };\n  const containerSize = {\n    width: container.clientWidth,\n    height: container.clientHeight\n  };\n  /**\n   * Reset the length of the resolved offset array rather than creating a new one.\n   * TODO: More reusable data structures for targetSize/containerSize would also be good.\n   */\n  info[axis].offset.length = 0;\n  /**\n   * Populate the offset array by resolving the user's offset definition into\n   * a list of pixel scroll offets.\n   */\n  let hasChanged = !info[axis].interpolate;\n  const numOffsets = offsetDefinition.length;\n  for (let i = 0; i < numOffsets; i++) {\n    const offset = (0, _offset.resolveOffset)(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n    if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n      hasChanged = true;\n    }\n    info[axis].offset[i] = offset;\n  }\n  /**\n   * If the pixel scroll offsets have changed, create a new interpolator function\n   * to map scroll value into a progress.\n   */\n  if (hasChanged) {\n    info[axis].interpolate = (0, _interpolate.interpolate)(info[axis].offset, (0, _default.defaultOffset)(offsetDefinition));\n    info[axis].interpolatorOffsets = [...info[axis].offset];\n  }\n  info[axis].progress = info[axis].interpolate(info[axis].current);\n}"},"sourceMaps":null,"error":null,"hash":"0a73bb11cbbe093baa9b3d5f13380e86","cacheData":{"env":{}}}