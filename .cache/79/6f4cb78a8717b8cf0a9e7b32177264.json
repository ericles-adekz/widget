{"id":"iouF","dependencies":[{"name":"C:\\Projetos\\adekz\\corporatefront_widget\\package.json","includedInParent":true,"mtime":1688673350195},{"name":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\package.json","includedInParent":true,"mtime":1688672641386},{"name":"../../../frameloop/index.mjs","loc":{"line":1,"column":35,"index":35},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\animation\\animators\\waapi\\create-accelerated-animation.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\frameloop\\index.mjs"},{"name":"./index.mjs","loc":{"line":2,"column":29,"index":96},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\animation\\animators\\waapi\\create-accelerated-animation.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\animation\\animators\\waapi\\index.mjs"},{"name":"./easing.mjs","loc":{"line":3,"column":39,"index":150},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\animation\\animators\\waapi\\create-accelerated-animation.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\animation\\animators\\waapi\\easing.mjs"},{"name":"./supports.mjs","loc":{"line":4,"column":25,"index":191},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\animation\\animators\\waapi\\create-accelerated-animation.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\animation\\animators\\waapi\\supports.mjs"},{"name":"./utils/get-final-keyframe.mjs","loc":{"line":5,"column":33,"index":242},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\animation\\animators\\waapi\\create-accelerated-animation.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\animation\\animators\\waapi\\utils\\get-final-keyframe.mjs"},{"name":"../js/index.mjs","loc":{"line":6,"column":29,"index":305},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\animation\\animators\\waapi\\create-accelerated-animation.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\animation\\animators\\js\\index.mjs"},{"name":"../../../utils/time-conversion.mjs","loc":{"line":7,"column":61,"index":385},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\animation\\animators\\waapi\\create-accelerated-animation.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\utils\\time-conversion.mjs"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createAcceleratedAnimation = createAcceleratedAnimation;\nvar _index = require(\"../../../frameloop/index.mjs\");\nvar _index2 = require(\"./index.mjs\");\nvar _easing = require(\"./easing.mjs\");\nvar _supports = require(\"./supports.mjs\");\nvar _getFinalKeyframe = require(\"./utils/get-final-keyframe.mjs\");\nvar _index3 = require(\"../js/index.mjs\");\nvar _timeConversion = require(\"../../../utils/time-conversion.mjs\");\n/**\n * A list of values that can be hardware-accelerated.\n */\nconst acceleratedValues = new Set([\"opacity\", \"clipPath\", \"filter\", \"transform\", \"backgroundColor\"]);\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\nconst sampleDelta = 10; //ms\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxDuration = 20000;\nconst requiresPregeneratedKeyframes = (valueName, options) => options.type === \"spring\" || valueName === \"backgroundColor\" || !(0, _easing.isWaapiSupportedEasing)(options.ease);\nfunction createAcceleratedAnimation(value, valueName, {\n  onUpdate,\n  onComplete,\n  ...options\n}) {\n  const canAccelerateAnimation = _supports.supports.waapi() && acceleratedValues.has(valueName) && !options.repeatDelay && options.repeatType !== \"mirror\" && options.damping !== 0 && options.type !== \"inertia\";\n  if (!canAccelerateAnimation) return false;\n  /**\n   * TODO: Unify with js/index\n   */\n  let hasStopped = false;\n  let resolveFinishedPromise;\n  let currentFinishedPromise;\n  /**\n   * Create a new finished Promise every time we enter the\n   * finished state and resolve the old Promise. This is\n   * WAAPI-compatible behaviour.\n   */\n  const updateFinishedPromise = () => {\n    currentFinishedPromise = new Promise(resolve => {\n      resolveFinishedPromise = resolve;\n    });\n  };\n  // Create the first finished promise\n  updateFinishedPromise();\n  let {\n    keyframes,\n    duration = 300,\n    ease,\n    times\n  } = options;\n  /**\n   * If this animation needs pre-generated keyframes then generate.\n   */\n  if (requiresPregeneratedKeyframes(valueName, options)) {\n    const sampleAnimation = (0, _index3.animateValue)({\n      ...options,\n      repeat: 0,\n      delay: 0\n    });\n    let state = {\n      done: false,\n      value: keyframes[0]\n    };\n    const pregeneratedKeyframes = [];\n    /**\n     * Bail after 20 seconds of pre-generated keyframes as it's likely\n     * we're heading for an infinite loop.\n     */\n    let t = 0;\n    while (!state.done && t < maxDuration) {\n      state = sampleAnimation.sample(t);\n      pregeneratedKeyframes.push(state.value);\n      t += sampleDelta;\n    }\n    times = undefined;\n    keyframes = pregeneratedKeyframes;\n    duration = t - sampleDelta;\n    ease = \"linear\";\n  }\n  const animation = (0, _index2.animateStyle)(value.owner.current, valueName, keyframes, {\n    ...options,\n    duration,\n    /**\n     * This function is currently not called if ease is provided\n     * as a function so the cast is safe.\n     *\n     * However it would be possible for a future refinement to port\n     * in easing pregeneration from Motion One for browsers that\n     * support the upcoming `linear()` easing function.\n     */\n    ease: ease,\n    times\n  });\n  const cancelAnimation = () => animation.cancel();\n  const safeCancel = () => {\n    _index.frame.update(cancelAnimation);\n    resolveFinishedPromise();\n    updateFinishedPromise();\n  };\n  /**\n   * Prefer the `onfinish` prop as it's more widely supported than\n   * the `finished` promise.\n   *\n   * Here, we synchronously set the provided MotionValue to the end\n   * keyframe. If we didn't, when the WAAPI animation is finished it would\n   * be removed from the element which would then revert to its old styles.\n   */\n  animation.onfinish = () => {\n    value.set((0, _getFinalKeyframe.getFinalKeyframe)(keyframes, options));\n    onComplete && onComplete();\n    safeCancel();\n  };\n  /**\n   * Animation interrupt callback.\n   */\n  return {\n    then(resolve, reject) {\n      return currentFinishedPromise.then(resolve, reject);\n    },\n    get time() {\n      return (0, _timeConversion.millisecondsToSeconds)(animation.currentTime || 0);\n    },\n    set time(newTime) {\n      animation.currentTime = (0, _timeConversion.secondsToMilliseconds)(newTime);\n    },\n    get speed() {\n      return animation.playbackRate;\n    },\n    set speed(newSpeed) {\n      animation.playbackRate = newSpeed;\n    },\n    get duration() {\n      return (0, _timeConversion.millisecondsToSeconds)(duration);\n    },\n    play: () => {\n      if (hasStopped) return;\n      animation.play();\n      /**\n       * Cancel any pending cancel tasks\n       */\n      (0, _index.cancelFrame)(cancelAnimation);\n    },\n    pause: () => animation.pause(),\n    stop: () => {\n      hasStopped = true;\n      if (animation.playState === \"idle\") return;\n      /**\n       * WAAPI doesn't natively have any interruption capabilities.\n       *\n       * Rather than read commited styles back out of the DOM, we can\n       * create a renderless JS animation and sample it twice to calculate\n       * its current value, \"previous\" value, and therefore allow\n       * Motion to calculate velocity for any subsequent animation.\n       */\n      const {\n        currentTime\n      } = animation;\n      if (currentTime) {\n        const sampleAnimation = (0, _index3.animateValue)({\n          ...options,\n          autoplay: false\n        });\n        value.setWithVelocity(sampleAnimation.sample(currentTime - sampleDelta).value, sampleAnimation.sample(currentTime).value, sampleDelta);\n      }\n      safeCancel();\n    },\n    complete: () => animation.finish(),\n    cancel: safeCancel\n  };\n}"},"sourceMaps":null,"error":null,"hash":"148f9e16f72937be40ab02aa083f6b33","cacheData":{"env":{}}}