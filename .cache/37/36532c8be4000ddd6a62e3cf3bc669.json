{"id":"dMUV","dependencies":[{"name":"C:\\Projetos\\adekz\\corporatefront_widget\\package.json","includedInParent":true,"mtime":1688673350195},{"name":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\package.json","includedInParent":true,"mtime":1688672641386},{"name":"../../../utils/errors.mjs","loc":{"line":1,"column":24,"index":24},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\animation\\generators\\spring\\find.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\utils\\errors.mjs"},{"name":"../../../utils/clamp.mjs","loc":{"line":2,"column":22,"index":75},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\animation\\generators\\spring\\find.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\utils\\clamp.mjs"},{"name":"../../../utils/time-conversion.mjs","loc":{"line":3,"column":61,"index":164},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\animation\\generators\\spring\\find.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\utils\\time-conversion.mjs"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.calcAngularFreq = calcAngularFreq;\nexports.findSpring = findSpring;\nexports.minDuration = exports.minDamping = exports.maxDuration = exports.maxDamping = void 0;\nvar _errors = require(\"../../../utils/errors.mjs\");\nvar _clamp = require(\"../../../utils/clamp.mjs\");\nvar _timeConversion = require(\"../../../utils/time-conversion.mjs\");\nconst safeMin = 0.001;\nconst minDuration = 0.01;\nexports.minDuration = minDuration;\nconst maxDuration = 10.0;\nexports.maxDuration = maxDuration;\nconst minDamping = 0.05;\nexports.minDamping = minDamping;\nconst maxDamping = 1;\nexports.maxDamping = maxDamping;\nfunction findSpring({\n  duration = 800,\n  bounce = 0.25,\n  velocity = 0,\n  mass = 1\n}) {\n  let envelope;\n  let derivative;\n  (0, _errors.warning)(duration <= (0, _timeConversion.secondsToMilliseconds)(maxDuration), \"Spring duration must be 10 seconds or less\");\n  let dampingRatio = 1 - bounce;\n  /**\n   * Restrict dampingRatio and duration to within acceptable ranges.\n   */\n  dampingRatio = (0, _clamp.clamp)(minDamping, maxDamping, dampingRatio);\n  duration = (0, _clamp.clamp)(minDuration, maxDuration, (0, _timeConversion.millisecondsToSeconds)(duration));\n  if (dampingRatio < 1) {\n    /**\n     * Underdamped spring\n     */\n    envelope = undampedFreq => {\n      const exponentialDecay = undampedFreq * dampingRatio;\n      const delta = exponentialDecay * duration;\n      const a = exponentialDecay - velocity;\n      const b = calcAngularFreq(undampedFreq, dampingRatio);\n      const c = Math.exp(-delta);\n      return safeMin - a / b * c;\n    };\n    derivative = undampedFreq => {\n      const exponentialDecay = undampedFreq * dampingRatio;\n      const delta = exponentialDecay * duration;\n      const d = delta * velocity + velocity;\n      const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n      const f = Math.exp(-delta);\n      const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n      const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n      return factor * ((d - e) * f) / g;\n    };\n  } else {\n    /**\n     * Critically-damped spring\n     */\n    envelope = undampedFreq => {\n      const a = Math.exp(-undampedFreq * duration);\n      const b = (undampedFreq - velocity) * duration + 1;\n      return -safeMin + a * b;\n    };\n    derivative = undampedFreq => {\n      const a = Math.exp(-undampedFreq * duration);\n      const b = (velocity - undampedFreq) * (duration * duration);\n      return a * b;\n    };\n  }\n  const initialGuess = 5 / duration;\n  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n  duration = (0, _timeConversion.secondsToMilliseconds)(duration);\n  if (isNaN(undampedFreq)) {\n    return {\n      stiffness: 100,\n      damping: 10,\n      duration\n    };\n  } else {\n    const stiffness = Math.pow(undampedFreq, 2) * mass;\n    return {\n      stiffness,\n      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n      duration\n    };\n  }\n}\nconst rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n  let result = initialGuess;\n  for (let i = 1; i < rootIterations; i++) {\n    result = result - envelope(result) / derivative(result);\n  }\n  return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}"},"sourceMaps":null,"error":null,"hash":"dd7d8c9b22d9c27c26ce86c8ac2ec2ff","cacheData":{"env":{}}}