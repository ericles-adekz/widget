{"id":"QDUS","dependencies":[{"name":"C:\\Projetos\\adekz\\corporatefront_widget\\package.json","includedInParent":true,"mtime":1688673350195},{"name":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\package.json","includedInParent":true,"mtime":1688672641386},{"name":"../../utils/is-numerical-string.mjs","loc":{"line":1,"column":34,"index":34},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\utils\\setters.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\utils\\is-numerical-string.mjs"},{"name":"../../utils/is-zero-value-string.mjs","loc":{"line":2,"column":34,"index":107},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\utils\\setters.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\utils\\is-zero-value-string.mjs"},{"name":"../../utils/resolve-value.mjs","loc":{"line":3,"column":45,"index":192},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\utils\\setters.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\utils\\resolve-value.mjs"},{"name":"../../value/index.mjs","loc":{"line":4,"column":28,"index":253},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\utils\\setters.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\value\\index.mjs"},{"name":"../../value/types/complex/index.mjs","loc":{"line":5,"column":24,"index":302},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\utils\\setters.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\value\\types\\complex\\index.mjs"},{"name":"../dom/value-types/animatable-none.mjs","loc":{"line":6,"column":34,"index":375},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\utils\\setters.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\dom\\value-types\\animatable-none.mjs"},{"name":"../dom/value-types/find.mjs","loc":{"line":7,"column":30,"index":447},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\utils\\setters.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\dom\\value-types\\find.mjs"},{"name":"./resolve-dynamic-variants.mjs","loc":{"line":8,"column":31,"index":509},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\utils\\setters.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\utils\\resolve-dynamic-variants.mjs"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkTargetForNewValues = checkTargetForNewValues;\nexports.getOrigin = getOrigin;\nexports.getOriginFromTransition = getOriginFromTransition;\nexports.setTarget = setTarget;\nexports.setValues = setValues;\nvar _isNumericalString = require(\"../../utils/is-numerical-string.mjs\");\nvar _isZeroValueString = require(\"../../utils/is-zero-value-string.mjs\");\nvar _resolveValue = require(\"../../utils/resolve-value.mjs\");\nvar _index = require(\"../../value/index.mjs\");\nvar _index2 = require(\"../../value/types/complex/index.mjs\");\nvar _animatableNone = require(\"../dom/value-types/animatable-none.mjs\");\nvar _find = require(\"../dom/value-types/find.mjs\");\nvar _resolveDynamicVariants = require(\"./resolve-dynamic-variants.mjs\");\n/**\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\n * it doesn't exist.\n */\nfunction setMotionValue(visualElement, key, value) {\n  if (visualElement.hasValue(key)) {\n    visualElement.getValue(key).set(value);\n  } else {\n    visualElement.addValue(key, (0, _index.motionValue)(value));\n  }\n}\nfunction setTarget(visualElement, definition) {\n  const resolved = (0, _resolveDynamicVariants.resolveVariant)(visualElement, definition);\n  let {\n    transitionEnd = {},\n    transition = {},\n    ...target\n  } = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {};\n  target = {\n    ...target,\n    ...transitionEnd\n  };\n  for (const key in target) {\n    const value = (0, _resolveValue.resolveFinalValueInKeyframes)(target[key]);\n    setMotionValue(visualElement, key, value);\n  }\n}\nfunction setVariants(visualElement, variantLabels) {\n  const reversedLabels = [...variantLabels].reverse();\n  reversedLabels.forEach(key => {\n    const variant = visualElement.getVariant(key);\n    variant && setTarget(visualElement, variant);\n    if (visualElement.variantChildren) {\n      visualElement.variantChildren.forEach(child => {\n        setVariants(child, variantLabels);\n      });\n    }\n  });\n}\nfunction setValues(visualElement, definition) {\n  if (Array.isArray(definition)) {\n    return setVariants(visualElement, definition);\n  } else if (typeof definition === \"string\") {\n    return setVariants(visualElement, [definition]);\n  } else {\n    setTarget(visualElement, definition);\n  }\n}\nfunction checkTargetForNewValues(visualElement, target, origin) {\n  var _a, _b;\n  const newValueKeys = Object.keys(target).filter(key => !visualElement.hasValue(key));\n  const numNewValues = newValueKeys.length;\n  if (!numNewValues) return;\n  for (let i = 0; i < numNewValues; i++) {\n    const key = newValueKeys[i];\n    const targetValue = target[key];\n    let value = null;\n    /**\n     * If the target is a series of keyframes, we can use the first value\n     * in the array. If this first value is null, we'll still need to read from the DOM.\n     */\n    if (Array.isArray(targetValue)) {\n      value = targetValue[0];\n    }\n    /**\n     * If the target isn't keyframes, or the first keyframe was null, we need to\n     * first check if an origin value was explicitly defined in the transition as \"from\",\n     * if not read the value from the DOM. As an absolute fallback, take the defined target value.\n     */\n    if (value === null) {\n      value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n    }\n    /**\n     * If value is still undefined or null, ignore it. Preferably this would throw,\n     * but this was causing issues in Framer.\n     */\n    if (value === undefined || value === null) continue;\n    if (typeof value === \"string\" && ((0, _isNumericalString.isNumericalString)(value) || (0, _isZeroValueString.isZeroValueString)(value))) {\n      // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n      value = parseFloat(value);\n    } else if (!(0, _find.findValueType)(value) && _index2.complex.test(targetValue)) {\n      value = (0, _animatableNone.getAnimatableNone)(key, targetValue);\n    }\n    visualElement.addValue(key, (0, _index.motionValue)(value, {\n      owner: visualElement\n    }));\n    if (origin[key] === undefined) {\n      origin[key] = value;\n    }\n    if (value !== null) visualElement.setBaseTarget(key, value);\n  }\n}\nfunction getOriginFromTransition(key, transition) {\n  if (!transition) return;\n  const valueTransition = transition[key] || transition[\"default\"] || transition;\n  return valueTransition.from;\n}\nfunction getOrigin(target, transition, visualElement) {\n  const origin = {};\n  for (const key in target) {\n    const transitionOrigin = getOriginFromTransition(key, transition);\n    if (transitionOrigin !== undefined) {\n      origin[key] = transitionOrigin;\n    } else {\n      const value = visualElement.getValue(key);\n      if (value) {\n        origin[key] = value.get();\n      }\n    }\n  }\n  return origin;\n}"},"sourceMaps":null,"error":null,"hash":"742e315fe5d1847e8352e88c932b7770","cacheData":{"env":{}}}