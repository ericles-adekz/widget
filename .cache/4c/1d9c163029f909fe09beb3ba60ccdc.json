{"id":"EOtF","dependencies":[{"name":"C:\\Projetos\\adekz\\corporatefront_widget\\package.json","includedInParent":true,"mtime":1688673350195},{"name":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\package.json","includedInParent":true,"mtime":1688672641386},{"name":"../../render/html/utils/transform.mjs","loc":{"line":1,"column":31,"index":31},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\animation\\optimized-appear\\handoff.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\html\\utils\\transform.mjs"},{"name":"../../utils/time-conversion.mjs","loc":{"line":2,"column":38,"index":110},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\animation\\optimized-appear\\handoff.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\utils\\time-conversion.mjs"},{"name":"./store.mjs","loc":{"line":3,"column":37,"index":182},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\animation\\optimized-appear\\handoff.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\animation\\optimized-appear\\store.mjs"},{"name":"./store-id.mjs","loc":{"line":4,"column":30,"index":227},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\animation\\optimized-appear\\handoff.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\animation\\optimized-appear\\store-id.mjs"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.handoffOptimizedAppearAnimation = handoffOptimizedAppearAnimation;\nvar _transform = require(\"../../render/html/utils/transform.mjs\");\nvar _timeConversion = require(\"../../utils/time-conversion.mjs\");\nvar _store = require(\"./store.mjs\");\nvar _storeId = require(\"./store-id.mjs\");\nfunction handoffOptimizedAppearAnimation(id, name, value,\n/**\n * This function is loaded via window by startOptimisedAnimation.\n * By accepting `sync` as an argument, rather than using it via\n * import, it can be kept out of the first-load Framer bundle,\n * while also allowing this function to not be included in\n * Framer Motion bundles where it's not needed.\n */\nframe) {\n  const storeId = (0, _storeId.appearStoreId)(id, _transform.transformProps.has(name) ? \"transform\" : name);\n  const appearAnimation = _store.appearAnimationStore.get(storeId);\n  if (!appearAnimation) return 0;\n  const {\n    animation,\n    startTime\n  } = appearAnimation;\n  const cancelOptimisedAnimation = () => {\n    _store.appearAnimationStore.delete(storeId);\n    /**\n     * Animation.cancel() throws so it needs to be wrapped in a try/catch\n     */\n    try {\n      animation.cancel();\n    } catch (e) {}\n  };\n  if (startTime !== null) {\n    const sampledTime = performance.now();\n    /**\n     * Resync handoff animation with optimised animation.\n     *\n     * This step would be unnecessary if we triggered animateChanges() in useEffect,\n     * but due to potential hydration errors we currently fire them in useLayoutEffect.\n     *\n     * By the time we're safely ready to cancel the optimised WAAPI animation,\n     * the main thread might have been blocked and desynced the two animations.\n     *\n     * Here, we resync the two animations before the optimised WAAPI animation is cancelled.\n     */\n    frame.update(() => {\n      if (value.animation) {\n        value.animation.time = (0, _timeConversion.millisecondsToSeconds)(performance.now() - sampledTime);\n      }\n    });\n    /**\n     * We allow the animation to persist until the next frame:\n     *   1. So it continues to play until Framer Motion is ready to render\n     *      (avoiding a potential flash of the element's original state)\n     *   2. As all independent transforms share a single transform animation, stopping\n     *      it synchronously would prevent subsequent transforms from handing off.\n     */\n    frame.render(cancelOptimisedAnimation);\n    /**\n     * We use main thread timings vs those returned by Animation.currentTime as it\n     * can be the case, particularly in Firefox, that currentTime doesn't return\n     * an updated value for several frames, even as the animation plays smoothly via\n     * the GPU.\n     */\n    return sampledTime - startTime || 0;\n  } else {\n    cancelOptimisedAnimation();\n    return 0;\n  }\n}"},"sourceMaps":null,"error":null,"hash":"538975370da942729d118bf0e9ca66d0","cacheData":{"env":{}}}