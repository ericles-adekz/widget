{"id":"I2US","dependencies":[{"name":"C:\\Projetos\\adekz\\corporatefront_widget\\package.json","includedInParent":true,"mtime":1688673350195},{"name":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\package.json","includedInParent":true,"mtime":1688672641386},{"name":"../../render/utils/resolve-dynamic-variants.mjs","loc":{"line":1,"column":31,"index":31},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\animation\\interfaces\\visual-element-variant.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\utils\\resolve-dynamic-variants.mjs"},{"name":"./visual-element-target.mjs","loc":{"line":2,"column":30,"index":112},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\animation\\interfaces\\visual-element-variant.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\animation\\interfaces\\visual-element-target.mjs"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.animateVariant = animateVariant;\nexports.sortByTreeOrder = sortByTreeOrder;\nvar _resolveDynamicVariants = require(\"../../render/utils/resolve-dynamic-variants.mjs\");\nvar _visualElementTarget = require(\"./visual-element-target.mjs\");\nfunction animateVariant(visualElement, variant, options = {}) {\n  const resolved = (0, _resolveDynamicVariants.resolveVariant)(visualElement, variant, options.custom);\n  let {\n    transition = visualElement.getDefaultTransition() || {}\n  } = resolved || {};\n  if (options.transitionOverride) {\n    transition = options.transitionOverride;\n  }\n  /**\n   * If we have a variant, create a callback that runs it as an animation.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n  const getAnimation = resolved ? () => Promise.all((0, _visualElementTarget.animateTarget)(visualElement, resolved, options)) : () => Promise.resolve();\n  /**\n   * If we have children, create a callback that runs all their animations.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n  const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {\n    const {\n      delayChildren = 0,\n      staggerChildren,\n      staggerDirection\n    } = transition;\n    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n  } : () => Promise.resolve();\n  /**\n   * If the transition explicitly defines a \"when\" option, we need to resolve either\n   * this animation or all children animations before playing the other.\n   */\n  const {\n    when\n  } = transition;\n  if (when) {\n    const [first, last] = when === \"beforeChildren\" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];\n    return first().then(() => last());\n  } else {\n    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n  }\n}\nfunction animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\n  const animations = [];\n  const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n  const generateStaggerDuration = staggerDirection === 1 ? (i = 0) => i * staggerChildren : (i = 0) => maxStaggerDuration - i * staggerChildren;\n  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i) => {\n    child.notify(\"AnimationStart\", variant);\n    animations.push(animateVariant(child, variant, {\n      ...options,\n      delay: delayChildren + generateStaggerDuration(i)\n    }).then(() => child.notify(\"AnimationComplete\", variant)));\n  });\n  return Promise.all(animations);\n}\nfunction sortByTreeOrder(a, b) {\n  return a.sortNodePosition(b);\n}"},"sourceMaps":null,"error":null,"hash":"8ed432bf2deda09a69736220ab014592","cacheData":{"env":{}}}