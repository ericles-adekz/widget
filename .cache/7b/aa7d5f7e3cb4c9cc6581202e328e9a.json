{"id":"rMvt","dependencies":[{"name":"C:\\Projetos\\adekz\\corporatefront_widget\\package.json","includedInParent":true,"mtime":1688673350195},{"name":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\package.json","includedInParent":true,"mtime":1688672641386},{"name":"../frameloop/index.mjs","loc":{"line":1,"column":35,"index":35},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\VisualElement.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\frameloop\\index.mjs"},{"name":"../utils/errors.mjs","loc":{"line":2,"column":35,"index":96},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\VisualElement.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\utils\\errors.mjs"},{"name":"../projection/geometry/models.mjs","loc":{"line":3,"column":26,"index":145},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\VisualElement.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\projection\\geometry\\models.mjs"},{"name":"../utils/is-ref-object.mjs","loc":{"line":4,"column":28,"index":210},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\VisualElement.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\utils\\is-ref-object.mjs"},{"name":"../utils/reduced-motion/index.mjs","loc":{"line":5,"column":41,"index":281},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\VisualElement.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\utils\\reduced-motion\\index.mjs"},{"name":"../utils/reduced-motion/state.mjs","loc":{"line":6,"column":63,"index":381},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\VisualElement.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\utils\\reduced-motion\\state.mjs"},{"name":"../utils/subscription-manager.mjs","loc":{"line":7,"column":36,"index":454},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\VisualElement.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\utils\\subscription-manager.mjs"},{"name":"../value/index.mjs","loc":{"line":8,"column":28,"index":519},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\VisualElement.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\value\\index.mjs"},{"name":"../value/use-will-change/is.mjs","loc":{"line":9,"column":40,"index":581},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\VisualElement.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\value\\use-will-change\\is.mjs"},{"name":"../value/utils/is-motion-value.mjs","loc":{"line":10,"column":30,"index":646},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\VisualElement.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\value\\utils\\is-motion-value.mjs"},{"name":"./html/utils/transform.mjs","loc":{"line":11,"column":31,"index":715},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\VisualElement.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\html\\utils\\transform.mjs"},{"name":"./utils/is-controlling-variants.mjs","loc":{"line":12,"column":53,"index":798},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\VisualElement.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\utils\\is-controlling-variants.mjs"},{"name":"./utils/is-variant-label.mjs","loc":{"line":13,"column":31,"index":868},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\VisualElement.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\utils\\is-variant-label.mjs"},{"name":"./utils/motion-values.mjs","loc":{"line":14,"column":44,"index":944},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\VisualElement.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\utils\\motion-values.mjs"},{"name":"./utils/resolve-variants.mjs","loc":{"line":15,"column":40,"index":1013},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\VisualElement.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\utils\\resolve-variants.mjs"},{"name":"../utils/warn-once.mjs","loc":{"line":16,"column":25,"index":1070},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\VisualElement.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\utils\\warn-once.mjs"},{"name":"../motion/features/definitions.mjs","loc":{"line":17,"column":35,"index":1131},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\VisualElement.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\motion\\features\\definitions.mjs"},{"name":"./utils/variant-props.mjs","loc":{"line":18,"column":29,"index":1198},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\VisualElement.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\utils\\variant-props.mjs"},{"name":"./store.mjs","loc":{"line":19,"column":35,"index":1262},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\VisualElement.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\render\\store.mjs"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VisualElement = void 0;\nvar _index = require(\"../frameloop/index.mjs\");\nvar _errors = require(\"../utils/errors.mjs\");\nvar _models = require(\"../projection/geometry/models.mjs\");\nvar _isRefObject = require(\"../utils/is-ref-object.mjs\");\nvar _index2 = require(\"../utils/reduced-motion/index.mjs\");\nvar _state = require(\"../utils/reduced-motion/state.mjs\");\nvar _subscriptionManager = require(\"../utils/subscription-manager.mjs\");\nvar _index3 = require(\"../value/index.mjs\");\nvar _is = require(\"../value/use-will-change/is.mjs\");\nvar _isMotionValue = require(\"../value/utils/is-motion-value.mjs\");\nvar _transform = require(\"./html/utils/transform.mjs\");\nvar _isControllingVariants = require(\"./utils/is-controlling-variants.mjs\");\nvar _isVariantLabel = require(\"./utils/is-variant-label.mjs\");\nvar _motionValues = require(\"./utils/motion-values.mjs\");\nvar _resolveVariants = require(\"./utils/resolve-variants.mjs\");\nvar _warnOnce = require(\"../utils/warn-once.mjs\");\nvar _definitions = require(\"../motion/features/definitions.mjs\");\nvar _variantProps = require(\"./utils/variant-props.mjs\");\nvar _store = require(\"./store.mjs\");\nconst featureNames = Object.keys(_definitions.featureDefinitions);\nconst numFeatures = featureNames.length;\nconst propEventHandlers = [\"AnimationStart\", \"AnimationComplete\", \"Update\", \"BeforeLayoutMeasure\", \"LayoutMeasure\", \"LayoutAnimationStart\", \"LayoutAnimationComplete\"];\nconst numVariantProps = _variantProps.variantProps.length;\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */\nclass VisualElement {\n  constructor({\n    parent,\n    props,\n    presenceContext,\n    reducedMotionConfig,\n    visualState\n  }, options = {}) {\n    /**\n     * A reference to the current underlying Instance, e.g. a HTMLElement\n     * or Three.Mesh etc.\n     */\n    this.current = null;\n    /**\n     * A set containing references to this VisualElement's children.\n     */\n    this.children = new Set();\n    /**\n     * Determine what role this visual element should take in the variant tree.\n     */\n    this.isVariantNode = false;\n    this.isControllingVariants = false;\n    /**\n     * Decides whether this VisualElement should animate in reduced motion\n     * mode.\n     *\n     * TODO: This is currently set on every individual VisualElement but feels\n     * like it could be set globally.\n     */\n    this.shouldReduceMotion = null;\n    /**\n     * A map of all motion values attached to this visual element. Motion\n     * values are source of truth for any given animated value. A motion\n     * value might be provided externally by the component via props.\n     */\n    this.values = new Map();\n    /**\n     * Cleanup functions for active features (hover/tap/exit etc)\n     */\n    this.features = {};\n    /**\n     * A map of every subscription that binds the provided or generated\n     * motion values onChange listeners to this visual element.\n     */\n    this.valueSubscriptions = new Map();\n    /**\n     * A reference to the previously-provided motion values as returned\n     * from scrapeMotionValuesFromProps. We use the keys in here to determine\n     * if any motion values need to be removed after props are updated.\n     */\n    this.prevMotionValues = {};\n    /**\n     * An object containing a SubscriptionManager for each active event.\n     */\n    this.events = {};\n    /**\n     * An object containing an unsubscribe function for each prop event subscription.\n     * For example, every \"Update\" event can have multiple subscribers via\n     * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n     */\n    this.propEventSubscriptions = {};\n    this.notifyUpdate = () => this.notify(\"Update\", this.latestValues);\n    this.render = () => {\n      if (!this.current) return;\n      this.triggerBuild();\n      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\n    };\n    this.scheduleRender = () => _index.frame.render(this.render, false, true);\n    const {\n      latestValues,\n      renderState\n    } = visualState;\n    this.latestValues = latestValues;\n    this.baseTarget = {\n      ...latestValues\n    };\n    this.initialValues = props.initial ? {\n      ...latestValues\n    } : {};\n    this.renderState = renderState;\n    this.parent = parent;\n    this.props = props;\n    this.presenceContext = presenceContext;\n    this.depth = parent ? parent.depth + 1 : 0;\n    this.reducedMotionConfig = reducedMotionConfig;\n    this.options = options;\n    this.isControllingVariants = (0, _isControllingVariants.isControllingVariants)(props);\n    this.isVariantNode = (0, _isControllingVariants.isVariantNode)(props);\n    if (this.isVariantNode) {\n      this.variantChildren = new Set();\n    }\n    this.manuallyAnimateOnMount = Boolean(parent && parent.current);\n    /**\n     * Any motion values that are provided to the element when created\n     * aren't yet bound to the element, as this would technically be impure.\n     * However, we iterate through the motion values and set them to the\n     * initial values for this component.\n     *\n     * TODO: This is impure and we should look at changing this to run on mount.\n     * Doing so will break some tests but this isn't neccessarily a breaking change,\n     * more a reflection of the test.\n     */\n    const {\n      willChange,\n      ...initialMotionValues\n    } = this.scrapeMotionValuesFromProps(props, {});\n    for (const key in initialMotionValues) {\n      const value = initialMotionValues[key];\n      if (latestValues[key] !== undefined && (0, _isMotionValue.isMotionValue)(value)) {\n        value.set(latestValues[key], false);\n        if ((0, _is.isWillChangeMotionValue)(willChange)) {\n          willChange.add(key);\n        }\n      }\n    }\n  }\n  /**\n   * This method takes React props and returns found MotionValues. For example, HTML\n   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n   *\n   * This isn't an abstract method as it needs calling in the constructor, but it is\n   * intended to be one.\n   */\n  scrapeMotionValuesFromProps(_props, _prevProps) {\n    return {};\n  }\n  mount(instance) {\n    this.current = instance;\n    _store.visualElementStore.set(instance, this);\n    if (this.projection && !this.projection.instance) {\n      this.projection.mount(instance);\n    }\n    if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n      this.removeFromVariantTree = this.parent.addVariantChild(this);\n    }\n    this.values.forEach((value, key) => this.bindToMotionValue(key, value));\n    if (!_state.hasReducedMotionListener.current) {\n      (0, _index2.initPrefersReducedMotion)();\n    }\n    this.shouldReduceMotion = this.reducedMotionConfig === \"never\" ? false : this.reducedMotionConfig === \"always\" ? true : _state.prefersReducedMotion.current;\n    if (\"production\" !== \"production\") {\n      (0, _warnOnce.warnOnce)(this.shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\");\n    }\n    if (this.parent) this.parent.children.add(this);\n    this.update(this.props, this.presenceContext);\n  }\n  unmount() {\n    _store.visualElementStore.delete(this.current);\n    this.projection && this.projection.unmount();\n    (0, _index.cancelFrame)(this.notifyUpdate);\n    (0, _index.cancelFrame)(this.render);\n    this.valueSubscriptions.forEach(remove => remove());\n    this.removeFromVariantTree && this.removeFromVariantTree();\n    this.parent && this.parent.children.delete(this);\n    for (const key in this.events) {\n      this.events[key].clear();\n    }\n    for (const key in this.features) {\n      this.features[key].unmount();\n    }\n    this.current = null;\n  }\n  bindToMotionValue(key, value) {\n    const valueIsTransform = _transform.transformProps.has(key);\n    const removeOnChange = value.on(\"change\", latestValue => {\n      this.latestValues[key] = latestValue;\n      this.props.onUpdate && _index.frame.update(this.notifyUpdate, false, true);\n      if (valueIsTransform && this.projection) {\n        this.projection.isTransformDirty = true;\n      }\n    });\n    const removeOnRenderRequest = value.on(\"renderRequest\", this.scheduleRender);\n    this.valueSubscriptions.set(key, () => {\n      removeOnChange();\n      removeOnRenderRequest();\n    });\n  }\n  sortNodePosition(other) {\n    /**\n     * If these nodes aren't even of the same type we can't compare their depth.\n     */\n    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {\n      return 0;\n    }\n    return this.sortInstanceNodePosition(this.current, other.current);\n  }\n  loadFeatures({\n    children,\n    ...renderedProps\n  }, isStrict, preloadedFeatures, initialLayoutGroupConfig) {\n    let ProjectionNodeConstructor;\n    let MeasureLayout;\n    /**\n     * If we're in development mode, check to make sure we're not rendering a motion component\n     * as a child of LazyMotion, as this will break the file-size benefits of using it.\n     */\n    if (\"production\" !== \"production\" && preloadedFeatures && isStrict) {\n      const strictMessage = \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\";\n      renderedProps.ignoreStrict ? (0, _errors.warning)(false, strictMessage) : (0, _errors.invariant)(false, strictMessage);\n    }\n    for (let i = 0; i < numFeatures; i++) {\n      const name = featureNames[i];\n      const {\n        isEnabled,\n        Feature: FeatureConstructor,\n        ProjectionNode,\n        MeasureLayout: MeasureLayoutComponent\n      } = _definitions.featureDefinitions[name];\n      if (ProjectionNode) ProjectionNodeConstructor = ProjectionNode;\n      if (isEnabled(renderedProps)) {\n        if (!this.features[name] && FeatureConstructor) {\n          this.features[name] = new FeatureConstructor(this);\n        }\n        if (MeasureLayoutComponent) {\n          MeasureLayout = MeasureLayoutComponent;\n        }\n      }\n    }\n    if (!this.projection && ProjectionNodeConstructor) {\n      this.projection = new ProjectionNodeConstructor(this.latestValues, this.parent && this.parent.projection);\n      const {\n        layoutId,\n        layout,\n        drag,\n        dragConstraints,\n        layoutScroll,\n        layoutRoot\n      } = renderedProps;\n      this.projection.setOptions({\n        layoutId,\n        layout,\n        alwaysMeasureLayout: Boolean(drag) || dragConstraints && (0, _isRefObject.isRefObject)(dragConstraints),\n        visualElement: this,\n        scheduleRender: () => this.scheduleRender(),\n        /**\n         * TODO: Update options in an effect. This could be tricky as it'll be too late\n         * to update by the time layout animations run.\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n         * ensuring it gets called if there's no potential layout animations.\n         *\n         */\n        animationType: typeof layout === \"string\" ? layout : \"both\",\n        initialPromotionConfig: initialLayoutGroupConfig,\n        layoutScroll,\n        layoutRoot\n      });\n    }\n    return MeasureLayout;\n  }\n  updateFeatures() {\n    for (const key in this.features) {\n      const feature = this.features[key];\n      if (feature.isMounted) {\n        feature.update();\n      } else {\n        feature.mount();\n        feature.isMounted = true;\n      }\n    }\n  }\n  triggerBuild() {\n    this.build(this.renderState, this.latestValues, this.options, this.props);\n  }\n  /**\n   * Measure the current viewport box with or without transforms.\n   * Only measures axis-aligned boxes, rotate and skew must be manually\n   * removed with a re-render to work.\n   */\n  measureViewportBox() {\n    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : (0, _models.createBox)();\n  }\n  getStaticValue(key) {\n    return this.latestValues[key];\n  }\n  setStaticValue(key, value) {\n    this.latestValues[key] = value;\n  }\n  /**\n   * Make a target animatable by Popmotion. For instance, if we're\n   * trying to animate width from 100px to 100vw we need to measure 100vw\n   * in pixels to determine what we really need to animate to. This is also\n   * pluggable to support Framer's custom value types like Color,\n   * and CSS variables.\n   */\n  makeTargetAnimatable(target, canMutate = true) {\n    return this.makeTargetAnimatableFromInstance(target, this.props, canMutate);\n  }\n  /**\n   * Update the provided props. Ensure any newly-added motion values are\n   * added to our map, old ones removed, and listeners updated.\n   */\n  update(props, presenceContext) {\n    if (props.transformTemplate || this.props.transformTemplate) {\n      this.scheduleRender();\n    }\n    this.prevProps = this.props;\n    this.props = props;\n    this.prevPresenceContext = this.presenceContext;\n    this.presenceContext = presenceContext;\n    /**\n     * Update prop event handlers ie onAnimationStart, onAnimationComplete\n     */\n    for (let i = 0; i < propEventHandlers.length; i++) {\n      const key = propEventHandlers[i];\n      if (this.propEventSubscriptions[key]) {\n        this.propEventSubscriptions[key]();\n        delete this.propEventSubscriptions[key];\n      }\n      const listener = props[\"on\" + key];\n      if (listener) {\n        this.propEventSubscriptions[key] = this.on(key, listener);\n      }\n    }\n    this.prevMotionValues = (0, _motionValues.updateMotionValuesFromProps)(this, this.scrapeMotionValuesFromProps(props, this.prevProps), this.prevMotionValues);\n    if (this.handleChildMotionValue) {\n      this.handleChildMotionValue();\n    }\n  }\n  getProps() {\n    return this.props;\n  }\n  /**\n   * Returns the variant definition with a given name.\n   */\n  getVariant(name) {\n    return this.props.variants ? this.props.variants[name] : undefined;\n  }\n  /**\n   * Returns the defined default transition on this component.\n   */\n  getDefaultTransition() {\n    return this.props.transition;\n  }\n  getTransformPagePoint() {\n    return this.props.transformPagePoint;\n  }\n  getClosestVariantNode() {\n    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : undefined;\n  }\n  getVariantContext(startAtParent = false) {\n    if (startAtParent) {\n      return this.parent ? this.parent.getVariantContext() : undefined;\n    }\n    if (!this.isControllingVariants) {\n      const context = this.parent ? this.parent.getVariantContext() || {} : {};\n      if (this.props.initial !== undefined) {\n        context.initial = this.props.initial;\n      }\n      return context;\n    }\n    const context = {};\n    for (let i = 0; i < numVariantProps; i++) {\n      const name = _variantProps.variantProps[i];\n      const prop = this.props[name];\n      if ((0, _isVariantLabel.isVariantLabel)(prop) || prop === false) {\n        context[name] = prop;\n      }\n    }\n    return context;\n  }\n  /**\n   * Add a child visual element to our set of children.\n   */\n  addVariantChild(child) {\n    const closestVariantNode = this.getClosestVariantNode();\n    if (closestVariantNode) {\n      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);\n      return () => closestVariantNode.variantChildren.delete(child);\n    }\n  }\n  /**\n   * Add a motion value and bind it to this visual element.\n   */\n  addValue(key, value) {\n    // Remove existing value if it exists\n    if (value !== this.values.get(key)) {\n      this.removeValue(key);\n      this.bindToMotionValue(key, value);\n    }\n    this.values.set(key, value);\n    this.latestValues[key] = value.get();\n  }\n  /**\n   * Remove a motion value and unbind any active subscriptions.\n   */\n  removeValue(key) {\n    this.values.delete(key);\n    const unsubscribe = this.valueSubscriptions.get(key);\n    if (unsubscribe) {\n      unsubscribe();\n      this.valueSubscriptions.delete(key);\n    }\n    delete this.latestValues[key];\n    this.removeValueFromRenderState(key, this.renderState);\n  }\n  /**\n   * Check whether we have a motion value for this key\n   */\n  hasValue(key) {\n    return this.values.has(key);\n  }\n  getValue(key, defaultValue) {\n    if (this.props.values && this.props.values[key]) {\n      return this.props.values[key];\n    }\n    let value = this.values.get(key);\n    if (value === undefined && defaultValue !== undefined) {\n      value = (0, _index3.motionValue)(defaultValue, {\n        owner: this\n      });\n      this.addValue(key, value);\n    }\n    return value;\n  }\n  /**\n   * If we're trying to animate to a previously unencountered value,\n   * we need to check for it in our state and as a last resort read it\n   * directly from the instance (which might have performance implications).\n   */\n  readValue(key) {\n    return this.latestValues[key] !== undefined || !this.current ? this.latestValues[key] : this.readValueFromInstance(this.current, key, this.options);\n  }\n  /**\n   * Set the base target to later animate back to. This is currently\n   * only hydrated on creation and when we first read a value.\n   */\n  setBaseTarget(key, value) {\n    this.baseTarget[key] = value;\n  }\n  /**\n   * Find the base target for a value thats been removed from all animation\n   * props.\n   */\n  getBaseTarget(key) {\n    var _a;\n    const {\n      initial\n    } = this.props;\n    const valueFromInitial = typeof initial === \"string\" || typeof initial === \"object\" ? (_a = (0, _resolveVariants.resolveVariantFromProps)(this.props, initial)) === null || _a === void 0 ? void 0 : _a[key] : undefined;\n    /**\n     * If this value still exists in the current initial variant, read that.\n     */\n    if (initial && valueFromInitial !== undefined) {\n      return valueFromInitial;\n    }\n    /**\n     * Alternatively, if this VisualElement config has defined a getBaseTarget\n     * so we can read the value from an alternative source, try that.\n     */\n    const target = this.getBaseTargetFromProps(this.props, key);\n    if (target !== undefined && !(0, _isMotionValue.isMotionValue)(target)) return target;\n    /**\n     * If the value was initially defined on initial, but it doesn't any more,\n     * return undefined. Otherwise return the value as initially read from the DOM.\n     */\n    return this.initialValues[key] !== undefined && valueFromInitial === undefined ? undefined : this.baseTarget[key];\n  }\n  on(eventName, callback) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = new _subscriptionManager.SubscriptionManager();\n    }\n    return this.events[eventName].add(callback);\n  }\n  notify(eventName, ...args) {\n    if (this.events[eventName]) {\n      this.events[eventName].notify(...args);\n    }\n  }\n}\nexports.VisualElement = VisualElement;"},"sourceMaps":null,"error":null,"hash":"f98792228ed5eb03993e85397be10fc0","cacheData":{"env":{"NODE_ENV":"production"}}}