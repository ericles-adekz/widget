{"id":"iuND","dependencies":[{"name":"C:\\Projetos\\adekz\\corporatefront_widget\\package.json","includedInParent":true,"mtime":1688673350195},{"name":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\package.json","includedInParent":true,"mtime":1688672641386},{"name":"react","loc":{"line":2,"column":75,"index":107},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\components\\AnimatePresence\\index.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\react\\index.js"},{"name":"../../utils/use-force-update.mjs","loc":{"line":3,"column":31,"index":147},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\components\\AnimatePresence\\index.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\utils\\use-force-update.mjs"},{"name":"../../utils/use-is-mounted.mjs","loc":{"line":4,"column":29,"index":212},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\components\\AnimatePresence\\index.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\utils\\use-is-mounted.mjs"},{"name":"./PresenceChild.mjs","loc":{"line":5,"column":30,"index":276},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\components\\AnimatePresence\\index.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\components\\AnimatePresence\\PresenceChild.mjs"},{"name":"../../context/LayoutGroupContext.mjs","loc":{"line":6,"column":35,"index":334},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\components\\AnimatePresence\\index.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\context\\LayoutGroupContext.mjs"},{"name":"../../utils/use-isomorphic-effect.mjs","loc":{"line":7,"column":42,"index":416},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\components\\AnimatePresence\\index.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\utils\\use-isomorphic-effect.mjs"},{"name":"../../utils/use-unmount-effect.mjs","loc":{"line":8,"column":33,"index":490},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\components\\AnimatePresence\\index.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\utils\\use-unmount-effect.mjs"},{"name":"../../utils/errors.mjs","loc":{"line":9,"column":26,"index":554},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\components\\AnimatePresence\\index.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\utils\\errors.mjs"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AnimatePresence = void 0;\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _useForceUpdate = require(\"../../utils/use-force-update.mjs\");\nvar _useIsMounted = require(\"../../utils/use-is-mounted.mjs\");\nvar _PresenceChild = require(\"./PresenceChild.mjs\");\nvar _LayoutGroupContext = require(\"../../context/LayoutGroupContext.mjs\");\nvar _useIsomorphicEffect = require(\"../../utils/use-isomorphic-effect.mjs\");\nvar _useUnmountEffect = require(\"../../utils/use-unmount-effect.mjs\");\nvar _errors = require(\"../../utils/errors.mjs\");\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nconst getChildKey = child => child.key || \"\";\nfunction updateChildLookup(children, allChildren) {\n  children.forEach(child => {\n    const key = getChildKey(child);\n    allChildren.set(key, child);\n  });\n}\nfunction onlyElements(children) {\n  const filtered = [];\n  // We use forEach here instead of map as map mutates the component key by preprending `.$`\n  React.Children.forEach(children, child => {\n    if ((0, React.isValidElement)(child)) filtered.push(child);\n  });\n  return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nconst AnimatePresence = ({\n  children,\n  custom,\n  initial = true,\n  onExitComplete,\n  exitBeforeEnter,\n  presenceAffectsLayout = true,\n  mode = \"sync\"\n}) => {\n  (0, _errors.invariant)(!exitBeforeEnter, \"Replace exitBeforeEnter with mode='wait'\");\n  // We want to force a re-render once all exiting animations have finished. We\n  // either use a local forceRender function, or one from a parent context if it exists.\n  const forceRender = (0, React.useContext)(_LayoutGroupContext.LayoutGroupContext).forceRender || (0, _useForceUpdate.useForceUpdate)()[0];\n  const isMounted = (0, _useIsMounted.useIsMounted)();\n  // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n  const filteredChildren = onlyElements(children);\n  let childrenToRender = filteredChildren;\n  const exitingChildren = (0, React.useRef)(new Map()).current;\n  // Keep a living record of the children we're actually rendering so we\n  // can diff to figure out which are entering and exiting\n  const presentChildren = (0, React.useRef)(childrenToRender);\n  // A lookup table to quickly reference components by key\n  const allChildren = (0, React.useRef)(new Map()).current;\n  // If this is the initial component render, just deal with logic surrounding whether\n  // we play onMount animations or not.\n  const isInitialRender = (0, React.useRef)(true);\n  (0, _useIsomorphicEffect.useIsomorphicLayoutEffect)(() => {\n    isInitialRender.current = false;\n    updateChildLookup(filteredChildren, allChildren);\n    presentChildren.current = childrenToRender;\n  });\n  (0, _useUnmountEffect.useUnmountEffect)(() => {\n    isInitialRender.current = true;\n    allChildren.clear();\n    exitingChildren.clear();\n  });\n  if (isInitialRender.current) {\n    return React.createElement(React.Fragment, null, childrenToRender.map(child => React.createElement(_PresenceChild.PresenceChild, {\n      key: getChildKey(child),\n      isPresent: true,\n      initial: initial ? undefined : false,\n      presenceAffectsLayout: presenceAffectsLayout,\n      mode: mode\n    }, child)));\n  }\n  // If this is a subsequent render, deal with entering and exiting children\n  childrenToRender = [...childrenToRender];\n  // Diff the keys of the currently-present and target children to update our\n  // exiting list.\n  const presentKeys = presentChildren.current.map(getChildKey);\n  const targetKeys = filteredChildren.map(getChildKey);\n  // Diff the present children with our target children and mark those that are exiting\n  const numPresent = presentKeys.length;\n  for (let i = 0; i < numPresent; i++) {\n    const key = presentKeys[i];\n    if (targetKeys.indexOf(key) === -1 && !exitingChildren.has(key)) {\n      exitingChildren.set(key, undefined);\n    }\n  }\n  // If we currently have exiting children, and we're deferring rendering incoming children\n  // until after all current children have exiting, empty the childrenToRender array\n  if (mode === \"wait\" && exitingChildren.size) {\n    childrenToRender = [];\n  }\n  // Loop through all currently exiting components and clone them to overwrite `animate`\n  // with any `exit` prop they might have defined.\n  exitingChildren.forEach((component, key) => {\n    // If this component is actually entering again, early return\n    if (targetKeys.indexOf(key) !== -1) return;\n    const child = allChildren.get(key);\n    if (!child) return;\n    const insertionIndex = presentKeys.indexOf(key);\n    let exitingComponent = component;\n    if (!exitingComponent) {\n      const onExit = () => {\n        allChildren.delete(key);\n        exitingChildren.delete(key);\n        // Remove this child from the present children\n        const removeIndex = presentChildren.current.findIndex(presentChild => presentChild.key === key);\n        presentChildren.current.splice(removeIndex, 1);\n        // Defer re-rendering until all exiting children have indeed left\n        if (!exitingChildren.size) {\n          presentChildren.current = filteredChildren;\n          if (isMounted.current === false) return;\n          forceRender();\n          onExitComplete && onExitComplete();\n        }\n      };\n      exitingComponent = React.createElement(_PresenceChild.PresenceChild, {\n        key: getChildKey(child),\n        isPresent: false,\n        onExitComplete: onExit,\n        custom: custom,\n        presenceAffectsLayout: presenceAffectsLayout,\n        mode: mode\n      }, child);\n      exitingChildren.set(key, exitingComponent);\n    }\n    childrenToRender.splice(insertionIndex, 0, exitingComponent);\n  });\n  // Add `MotionContext` even to children that don't need it to ensure we're rendering\n  // the same tree between renders\n  childrenToRender = childrenToRender.map(child => {\n    const key = child.key;\n    return exitingChildren.has(key) ? child : React.createElement(_PresenceChild.PresenceChild, {\n      key: getChildKey(child),\n      isPresent: true,\n      presenceAffectsLayout: presenceAffectsLayout,\n      mode: mode\n    }, child);\n  });\n  if (\"production\" !== \"production\" && mode === \"wait\" && childrenToRender.length > 1) {\n    console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`);\n  }\n  return React.createElement(React.Fragment, null, exitingChildren.size ? childrenToRender : childrenToRender.map(child => (0, React.cloneElement)(child)));\n};\nexports.AnimatePresence = AnimatePresence;"},"sourceMaps":null,"error":null,"hash":"3c8edf45ed7f9b1fea628d986ccbf044","cacheData":{"env":{"NODE_ENV":"production"}}}