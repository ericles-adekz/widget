{"id":"aKhv","dependencies":[{"name":"C:\\Projetos\\adekz\\corporatefront_widget\\package.json","includedInParent":true,"mtime":1688673350195},{"name":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\package.json","includedInParent":true,"mtime":1688672641386},{"name":"../../easing/circ.mjs","loc":{"line":1,"column":24,"index":24},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\projection\\animation\\mix-values.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\easing\\circ.mjs"},{"name":"../../utils/progress.mjs","loc":{"line":2,"column":25,"index":74},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\projection\\animation\\mix-values.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\utils\\progress.mjs"},{"name":"../../utils/mix.mjs","loc":{"line":3,"column":20,"index":122},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\projection\\animation\\mix-values.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\utils\\mix.mjs"},{"name":"../../utils/noop.mjs","loc":{"line":4,"column":21,"index":166},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\projection\\animation\\mix-values.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\utils\\noop.mjs"},{"name":"../../value/types/numbers/units.mjs","loc":{"line":5,"column":28,"index":218},"parent":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\projection\\animation\\mix-values.mjs","resolved":"C:\\Projetos\\adekz\\corporatefront_widget\\node_modules\\framer-motion\\dist\\es\\value\\types\\numbers\\units.mjs"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mixValues = mixValues;\nvar _circ = require(\"../../easing/circ.mjs\");\nvar _progress = require(\"../../utils/progress.mjs\");\nvar _mix = require(\"../../utils/mix.mjs\");\nvar _noop = require(\"../../utils/noop.mjs\");\nvar _units = require(\"../../value/types/numbers/units.mjs\");\nconst borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nconst numBorders = borders.length;\nconst asNumber = value => typeof value === \"string\" ? parseFloat(value) : value;\nconst isPx = value => typeof value === \"number\" || _units.px.test(value);\nfunction mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {\n  if (shouldCrossfadeOpacity) {\n    target.opacity = (0, _mix.mix)(0,\n    // TODO Reinstate this if only child\n    lead.opacity !== undefined ? lead.opacity : 1, easeCrossfadeIn(progress));\n    target.opacityExit = (0, _mix.mix)(follow.opacity !== undefined ? follow.opacity : 1, 0, easeCrossfadeOut(progress));\n  } else if (isOnlyMember) {\n    target.opacity = (0, _mix.mix)(follow.opacity !== undefined ? follow.opacity : 1, lead.opacity !== undefined ? lead.opacity : 1, progress);\n  }\n  /**\n   * Mix border radius\n   */\n  for (let i = 0; i < numBorders; i++) {\n    const borderLabel = `border${borders[i]}Radius`;\n    let followRadius = getRadius(follow, borderLabel);\n    let leadRadius = getRadius(lead, borderLabel);\n    if (followRadius === undefined && leadRadius === undefined) continue;\n    followRadius || (followRadius = 0);\n    leadRadius || (leadRadius = 0);\n    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);\n    if (canMix) {\n      target[borderLabel] = Math.max((0, _mix.mix)(asNumber(followRadius), asNumber(leadRadius), progress), 0);\n      if (_units.percent.test(leadRadius) || _units.percent.test(followRadius)) {\n        target[borderLabel] += \"%\";\n      }\n    } else {\n      target[borderLabel] = leadRadius;\n    }\n  }\n  /**\n   * Mix rotation\n   */\n  if (follow.rotate || lead.rotate) {\n    target.rotate = (0, _mix.mix)(follow.rotate || 0, lead.rotate || 0, progress);\n  }\n}\nfunction getRadius(values, radiusName) {\n  return values[radiusName] !== undefined ? values[radiusName] : values.borderRadius;\n}\n// /**\n//  * We only want to mix the background color if there's a follow element\n//  * that we're not crossfading opacity between. For instance with switch\n//  * AnimateSharedLayout animations, this helps the illusion of a continuous\n//  * element being animated but also cuts down on the number of paints triggered\n//  * for elements where opacity is doing that work for us.\n//  */\n// if (\n//     !hasFollowElement &&\n//     latestLeadValues.backgroundColor &&\n//     latestFollowValues.backgroundColor\n// ) {\n//     /**\n//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n//      * We could probably create a mixer that runs at the start of the animation but\n//      * the idea behind the crossfader is that it runs dynamically between two potentially\n//      * changing targets (ie opacity or borderRadius may be animating independently via variants)\n//      */\n//     leadState.backgroundColor = followState.backgroundColor = mixColor(\n//         latestFollowValues.backgroundColor as string,\n//         latestLeadValues.backgroundColor as string\n//     )(p)\n// }\nconst easeCrossfadeIn = compress(0, 0.5, _circ.circOut);\nconst easeCrossfadeOut = compress(0.5, 0.95, _noop.noop);\nfunction compress(min, max, easing) {\n  return p => {\n    // Could replace ifs with clamp\n    if (p < min) return 0;\n    if (p > max) return 1;\n    return easing((0, _progress.progress)(min, max, p));\n  };\n}"},"sourceMaps":null,"error":null,"hash":"34b2c95aabdb2a065cd22aa4b4faadf6","cacheData":{"env":{}}}